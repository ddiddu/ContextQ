<!-- Apps Script does not serve .js files from its file tree like a normal web server -->
<script>
const globalToneMap = {
    1: "very critical",
    2: "critical",
    3: "neutral",
    4: "positive",
    5: "very positive"
};

let lastGeneratedContext = ''; // Store the last saved value
let lastGeneratedTone = '';
let lastGeneratedType = '';
let selectedToneValue = 3; // from slider (1-5)
let selectedToneLabel = globalToneMap[selectedToneValue]; // mapped label
let selectedTypes = null; // plural, for multiple card selections
let currentGeneratedQuestions = []; // Global variable to store currently generated questions
let selectedComment = null;

// 1ï¸âƒ£ STEP 1: ë°œí‘œ ëª©ì  ì…ë ¥ 
function autoResize(textarea) {
    textarea.style.height = 'auto';
    const computedStyle = window.getComputedStyle(textarea);
    const paddingTop = parseFloat(computedStyle.paddingTop);
    const paddingBottom = parseFloat(computedStyle.paddingBottom);
    const borderTop = parseFloat(computedStyle.borderTopWidth);
    const borderBottom = parseFloat(computedStyle.borderBottomWidth);
    const scrollHeight = textarea.scrollHeight;

    textarea.style.height = `${scrollHeight - paddingTop - paddingBottom - borderTop - borderBottom}px`;
}

document.getElementById('presentation-purpose').addEventListener('input', function () {
    const saveButton = document.getElementById('save-button');
    const currentValue = this.value.trim();

    // ë²„íŠ¼ í™œì„±í™” ì¡°ê±´: ë‚´ìš©ì´ ìˆê³ , ë§ˆì§€ë§‰ ì €ì¥ ê°’ê³¼ ë‹¤ë¥¼ ë•Œ
    saveButton.disabled = currentValue === '' || currentValue === lastGeneratedContext;

    autoResize(this); // ë†’ì´ ìë™ ì¡°ì ˆ
});

// 2ï¸âƒ£ STEP 2: ë°œí‘œ ëª©ì  ì €ì¥ ë° Tone ì„ íƒ 
function selectTone() {
    selectedComment = null; // ì¹´ë“œ ì„ íƒ ì´ˆê¸°í™”

    const textarea = document.getElementById('presentation-purpose');
    const saveButton = document.getElementById('save-button');
    const currentValue = textarea.value.trim();

    if (currentValue === '') {
        alert('Please enter a presentation description before continuing.');
        return;
    }

    lastGeneratedContext = currentValue; // Update the saved value
    saveButton.disabled = true; // Disable the button

    const container = document.getElementById('tone-container');
    container.innerHTML = `
    <div style="margin-bottom: 4px;">
        <div style="font-size: 14px; font-weight: 500;">Select your desired comment tone.</div>
        <div style="font-size: 12px; color: #6b7280;">(Only one tone can be selected. You can change this later.)</div>
    </div>

    <div id="questions-display" style="margin-top: 10px;">
        <!-- Questions will be dynamically displayed here -->
    </div>

    <md-filled-button id="next-button" onclick="selectType()" disabled style="margin-top: 0px;">Next</md-filled-button>
    `;

    // Example comments to display
    const exampleComments = [
        { questions: [{ slide: "A", question: "These points lack any definition of key termsâ€”both 'AI teammates' and 'mixed-motived tasking' are left ambiguous, making it hard for the audience to follow your argument or understand the significance of the problems." }] },
        { questions: [{ slide: "B", question: "Consider defining 'mixed-motived tasking' more explicitly, as this concept may not be familiar to all members of your audience." }] },
        { questions: [{ slide: "C", question: "Fantastic opening! For even greater clarity, perhaps briefly define 'mixed-motive tasking' since that concept is central to your argument and some listeners may be unfamiliar with it." }] }
    ];

    // Call displayQuestions with hideDetails = true and allowMultiple = false
    displayQuestions(exampleComments, true, false);
}

// 3ï¸âƒ£ STEP 3: Tone ì €ì¥ ë° Type ì„ íƒ 
function selectType() {
    // STEP 3.1: Tone ì €ì¥
    const toneMap = { A: 1, B: 3, C: 5 };
    // STEP 3.1.1: ì„ íƒëœ ì¹´ë“œ ì½”ë“œ ê°€ì ¸ì˜¤ê¸°
    const toneCode = selectedComment; // ex: "A", "B", or "C"
    selectedComment = null; // ì¹´ë“œ ì„ íƒ ì´ˆê¸°í™”
    // STEP 3.1.2: ì½”ë“œ â†’ ìˆ«ì ë³€í™˜
    const toneValue = toneMap[toneCode] || 3; // default to 3 ("neutral") if not found
    // STEP 3.1.3: tone ì—…ë°ì´íŠ¸ í•¨ìˆ˜ í˜¸ì¶œ
    // ì´ í•¨ìˆ˜ê°€ window.selectedTone ì„ stringìœ¼ë¡œ ì„¤ì •í•¨
    // Save both numeric value and string label
    window.selectedToneValue = Number(toneValue);
    window.selectedToneLabel = globalToneMap[toneValue];

    // STEP 3.2: Type ì„ íƒ
    const container = document.getElementById('tone-container');
    container.innerHTML = `
    <div style="margin-bottom: 4px;">
        <div style="font-size: 14px; font-weight: 500;">Select your desired comment type.</div>
        <div style="font-size: 12px; color: #6b7280;">(Both types can be selected. You can change this later.)</div>
    </div>

    <div id="questions-display" style="margin-top: 10px;">
        <!-- Questions will be dynamically displayed here -->
    </div>

    <div style="display: flex; justify-content: space-between; gap: 5px; margin-top: -10px;">
        <md-filled-button id="prev-button" onclick="selectTone()">Prev</md-filled-button>
        <md-filled-button id="next-button" onclick="confirmTypeAndGenerate()" disabled>Next</md-filled-button>
    </div>
    `;

    // Example comments to display
    const exampleComments = [
        { questions: [{ slide: "A", question: "In what ways do you think the limitations of current social cue-based methods could impact the integrity of cooperative team dynamics with AI teammates?" }] },
        { questions: [{ slide: "B", question: "Integrate brief summaries or implications for each referenced study to clarify their relevance to your thesis idea." }] }
    ];

    // Call displayQuestions with hideDetails = true and allowMultiple = true
    displayQuestions(exampleComments, true, true);
}

// 4ï¸âƒ£ Step 4: Type ì €ì¥ ë° Generate Questions
// Step 4.1: Type ì €ì¥
function confirmTypeAndGenerate() {
    // ëª…ì‹œì  ë°©ì–´ ì½”ë“œ: selectedCommentê°€ nullì´ë©´ ì ˆëŒ€ ì§„í–‰ X
    if (!selectedComment || (Array.isArray(selectedComment) && selectedComment.length === 0)) {
        alert("Please select a comment type before continuing.");
        return;
    }

    // ì•„ë˜ë¶€í„°ëŠ” ì¡°ê±´ ë§Œì¡±í–ˆì„ ë•Œë§Œ ì‹¤í–‰
    selectedTypes = selectedComment;
    window.selectedType = "all";
    if (Array.isArray(selectedTypes)) {
        if (selectedTypes.length === 1 && selectedTypes[0] === "A") window.selectedType = "low";
        else if (selectedTypes.length === 1 && selectedTypes[0] === "B") window.selectedType = "high";
    }

    generateQuestions();
}

// Step 4.2: Generate Questions
function generateQuestions(toneOverride, typeOverride, extraQuestions = []) {
    // Get the user-provided context from the input field
    const contextInput = document.getElementById('presentation-purpose').value.trim();
    if (!contextInput) {
        console.log("No context provided.");
        alert("Please enter a context before proceeding.");
        return; // Return false if validation fails
    }
    // Prepare the context object
    const selectedContexts = [{context: contextInput,}];

    const tone = toneOverride || window.selectedToneLabel;
    const type = typeOverride || window.selectedType;

    const container = document.getElementById('tone-container');
    container.innerHTML = `
    <div id="loading-indicator">
        <md-circular-progress indeterminate></md-circular-progress>
        <div style="font-size: 14px; font-weight: 500; margin-top: 5px;">Generating comments for your presentation...</div>
    </div>
    `;

    // Call the Google Apps Script function
    google.script.run
    .withSuccessHandler(function(currentQuestions) {
        console.log("âœ… Success handler called.");
        console.log("Generated questions:", currentQuestions);

        attachButtonListeners();   // <-- add listeners after render
        checkButtonStates();

        // Save the last generated state
        lastGeneratedContext = contextInput;
        lastGeneratedTone = tone;
        lastGeneratedType = type;

        console.log("Generate questions for", lastGeneratedContext,"with tone:", lastGeneratedTone, "and type:", lastGeneratedType);

        // Map selected tone to slider value
        const defaultToneValue = window.selectedToneValue || 3; // Default to 3 if not set

        const container = document.getElementById('tone-container');
        container.innerHTML = `
        <div id="questions-section">
            <div style="margin-bottom: 4px;">
                <div style="font-size: 14px; font-weight: 500;">Customize comment tone and type.</div>
            </div>

            <div class="tone-slider-wrapper" style="margin-top: 10px;">
                <div class="tone-end-label">Critical</div>
                <input 
                    type="range" min="1" max="5" step="1" value="${defaultToneValue}" 
                    class="tone-slider" id="tone-range" oninput="updateToneLabel(this.value)"
                />
                <div class="tone-end-label">Positive</div>
            </div>

            <div class="radio-group">
                <label class="radio-option">
                    <input type="radio" name="type" value="low" ${selectedType === 'low' ? 'checked' : ''} onchange="updateTypeLabel(this.value)">
                    <span class="custom-radio"></span>
                    Question
                </label>
                <label class="radio-option">
                    <input type="radio" name="type" value="high" ${selectedType === 'high' ? 'checked' : ''} onchange="updateTypeLabel(this.value)">
                    <span class="custom-radio"></span>
                    Feedback
                </label>
                <label class="radio-option">
                    <input type="radio" name="type" value="all" ${selectedType === 'all' ? 'checked' : ''} onchange="updateTypeLabel(this.value)">
                    <span class="custom-radio"></span>
                    Both
                </label>
            </div>

            <!--
            <md-filled-button id="apply-button" onclick="filterQuestionsByToneAndType()" style="margin-top: 8px;">
                Apply
            </md-filled-button>
            -->

            <div id="buttons" style="display: flex; justify-content: space-between; gap: 5px; margin-top: 5px;">
                <md-filled-button id="update-button" onclick="filterQuestionsByToneAndType()">Apply</md-filled-button>
                <!-- <md-filled-button id="regenerate-button" onclick="regenerateQuestions()">Regenerate</md-filled-button> -->
            </div>

            <div id="questions-display-main" style="margin-top: 20px;">
            <!-- Questions will be dynamically displayed here -->
            </div>
        </div>
        `;

        const saveButton = document.getElementById("buttons");
        if (saveButton) {
            saveButton.innerHTML = `
            <!--
            <md-filled-button id="regenerate-button" onclick="generateQuestions()" style="margin-top: -10px; margin-bottom: 20px;">
                Regenerate
            </md-filled-button>
            -->
            `;
        }

        attachButtonListeners();

        // Merge extraQuestions with the newly generated questions
        const allQuestions = [...extraQuestions, ...currentQuestions];

        // Store the generated questions in the global variable
        currentGeneratedQuestions = [...currentGeneratedQuestions, ...currentQuestions];

        // Display the newly generated questions directly below
        displayQuestions(allQuestions);
    })
    .withFailureHandler(function(error) {
        console.log("Failure handler called.");
        console.error("Error generating questions:", error);

        // Hide loading indicator and remove overlay
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) loadingIndicator.style.display = 'none';

        alert("Failed to generate questions. Please try again.");
    })
    .generateComments(selectedContexts, tone, type, debugging=false);// Pass the context object to the server-side function
}

function hasMatchingComments(tone, type) {
    return currentGeneratedQuestions.some(item => {
        return item.questions.some(q => {
            const toneMatches = q.tone === tone;
            const typeMatches = type === 'all' || q.assistanceLevel === type;
            return toneMatches && typeMatches; // Match both tone and type
        });
    });
}

// 5ï¸âƒ£ Step 5: Filter Questions by Tone and Type
function filterQuestionsByToneAndType() {
    const selectedTone = window.selectedToneLabel || "neutral"; // ê¸°ë³¸ê°’ fallback    
    const selectedType = window.selectedType || "all"; // Default to "all" if not set

    // Combine saved questions and currently generated questions
    const allQuestions = currentGeneratedQuestions

    console.log("Filtering questions with tone:", selectedTone, "and type:", selectedType);

    const currentContext = document.getElementById('presentation-purpose').value.trim();
    const contextUnchanged = currentContext === lastGeneratedContext;

    if (!contextUnchanged) {
        console.log("ğŸ” Context has changed. Clearing questions and regenerating...");
        
        // Clear existing questions and reset recent comments
        currentGeneratedQuestions = [];
        selectedComment = null;

        // Regenerate questions for the new context
        generateQuestions(selectedTone, selectedType);
        return;
    }

    const filteredQuestions = allQuestions.map(item => {
        return {
        questions: item.questions.filter(q => {
            const toneMatches = q.tone === selectedTone;
            const typeMatches = selectedType === 'all' || q.assistanceLevel === selectedType;
            return toneMatches && typeMatches; // Match both tone and type
        })
        };
    }).filter(item => item.questions.length > 0); // Remove personas with no matching questions

    const flat = filteredQuestions.flatMap(p => p.questions);

    if (selectedType === 'all') {
    const hasLow = flat.some(q => q.assistanceLevel === 'low');
    const hasHigh = flat.some(q => q.assistanceLevel === 'high');

    if (!hasLow || !hasHigh) {
        const missingType = !hasLow ? 'low' : 'high';
        console.log(`ğŸ” Missing ${missingType} comments â€” generating just those.`);
        // Pass the filteredQuestions as extraQuestions
        generateQuestions(selectedTone, missingType, filteredQuestions);
        return;
    }
    }

    if (flat.length === 0) {
    console.log("ğŸ” No matching questions found. Generating...");
    generateQuestions(selectedTone, selectedType);
    return;
    }

    displayQuestions(filteredQuestions);
}

function updateToneLabel(value) {
    const tone = globalToneMap[value];

    // ì„ íƒëœ toneì„ ì‹¤ì œë¡œ ì–´ë”˜ê°€ì— ì €ì¥í•˜ê±°ë‚˜ í•„í„°ë§ì— í™œìš©í•˜ë ¤ë©´:
    // ì˜ˆ: ê¸€ë¡œë²Œ ë³€ìˆ˜, hidden input, ë˜ëŠ” ì§ì ‘ ì§ˆë¬¸ í•„í„°ë§ í•¨ìˆ˜ í˜¸ì¶œ
    // Save both numeric value and string label
    window.selectedToneValue = Number(value);
    window.selectedToneLabel = tone;

    // filterQuestionsByToneAndType(); // ì´ í•¨ìˆ˜ì—ì„œ window.selectedTone í™œìš© ê°€ëŠ¥
}

function updateTypeLabel(value) {
    // Update the selected type globally
    window.selectedType = value;

    // Call the function to filter questions based on the selected tone and type
    // filterQuestionsByToneAndType();
}

// External function to validate context input
function validateContextInput() {
    const contextInput = document.getElementById('presentation-purpose').value.trim();
    if (!contextInput) {
        console.log("No context provided.");
        alert(CONTEXT_REQUIRED_MESSAGE);
        return false; // Return false if validation fails
    }
    return contextInput; // Return the valid input
}

// 6ï¸âƒ£ Step 6: Regenerate Questions
function regenerateQuestions() {
    const currentTone = window.selectedToneLabel || '';
    const currentType = window.selectedType || 'all';

    // Filter out only the questions that match the current tone and type
    currentGeneratedQuestions = currentGeneratedQuestions.filter(item => {
        return !item.questions.some(q => {
            const toneMatches = q.tone === currentTone;
            const typeMatches = currentType === 'all' || q.assistanceLevel === currentType;
            return toneMatches && typeMatches; // Remove only matching questions
        });
    });

    // Regenerate only the selected tone and type
    generateQuestions(currentTone, currentType);
}

// External function to validate context input
function toggleCardSelection(cardElement, allowMultiple = false) {
    if (!allowMultiple) {
        const isSelected = cardElement.classList.contains('selected');
        document.querySelectorAll('.card').forEach(card => card.classList.remove('selected'));

        if (!isSelected) {
            cardElement.classList.add('selected');
            const nextButton = document.getElementById('next-button');
            if (nextButton) {
                nextButton.disabled = false;
            }

            selectedComment = cardElement.querySelector('.card-header').textContent.replace('Option ', '').trim();
        } else {
            selectedComment = null; // ê°•ì œ ì´ˆê¸°í™”
            document.getElementById('next-button').disabled = true;
        }
    } else {
        cardElement.classList.toggle('selected');
        const selectedCards = document.querySelectorAll('.card.selected');
        const anySelected = selectedCards.length > 0;
        document.getElementById('next-button').disabled = !anySelected;

        selectedComment = Array.from(selectedCards).map(card =>
            card.querySelector('.card-header').textContent.replace('Option ', '').trim()
        );
    }
}

function toggleThumb(button, direction) {
    const isSelected = button.classList.contains('active');
    
    // Remove active state from both buttons in the same container
    const siblings = button.parentElement.querySelectorAll('.thumb-button');
    siblings.forEach(btn => btn.classList.remove('active'));

    // Toggle only if not already active
    if (!isSelected) {
        button.classList.add('active');
    }
}

// Function to toggle the explanation visibility
function toggleExplanation(id) {
    const explanationDiv = document.getElementById(id);
    if (explanationDiv) {
    explanationDiv.style.display = (explanationDiv.style.display === 'none') ? 'block' : 'none';
    }
}

function displayQuestions(questions, hideDetails = false, allowMultiple = false) {
    const displayId = hideDetails ? 'questions-display' : 'questions-display-main';
    const displayDiv = document.getElementById(displayId);
    displayDiv.innerHTML = '';

    if (!questions || questions.length === 0) {
        displayDiv.innerHTML = `
        <div 
            style="background-color: #f9fafb; border: 1px solid #e5e7eb; border-radius: 12px;
            padding: 16px; color: #6b7280; font-size: 14px; text-align: center;">
            Please select a tone and type to see results.
        </div>`;
        return;
    }

    questions.forEach(item => {
        item.questions.forEach((q, index) => {
        displayDiv.innerHTML += displayCard(q, index, hideDetails, allowMultiple);
        });
    });
}

function checkButtonStates() {
    const currentContext = document.getElementById('presentation-purpose').value.trim();
    const currentTone = window.selectedToneLabel || '';
    const currentType = window.selectedType || '';

    // Check if the context, tone, and type haven't changed
    const contextUnchanged = currentContext === lastGeneratedContext;
    const toneUnchanged = currentTone === lastGeneratedTone;
    const typeUnchanged = currentType === lastGeneratedType;

    // Use the external hasMatchingComments function to check for existing comments
    const hasComments = hasMatchingComments(currentTone, currentType);

    // Additional check for "all" type
    let hasAllComments = true;
    if (currentType === 'all') {
        const hasLow = hasMatchingComments(currentTone, 'low');
        const hasHigh = hasMatchingComments(currentTone, 'high');
        hasAllComments = hasLow && hasHigh; // Ensure both low and high are present
    }

    // Safely get the regenerate button
    const regenerateBtn = document.getElementById('regenerate-button');

    // Enable the regenerate button only if all conditions are met
    if (regenerateBtn) {
        regenerateBtn.disabled = !(contextUnchanged && toneUnchanged && typeUnchanged && hasComments && hasAllComments);
    }
}

function attachButtonListeners() {
    // Only attach if these elements exist
    const contextInput = document.getElementById('presentation-purpose');
    if (contextInput) contextInput.addEventListener('input', checkButtonStates);

    const toneRange = document.getElementById('tone-range');
    if (toneRange) toneRange.addEventListener('input', checkButtonStates);

    document.querySelectorAll('input[name="type"]').forEach(radio => {
        radio.addEventListener('change', checkButtonStates);
    });
}
</script>